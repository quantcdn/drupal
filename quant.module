<?php

/**
 * @file
 * Support exporting to Quant.
 */

/**
 * The regular expression to find theme assets.
 *
 * @var string
 */
define('QUANT_THEME_FILE_MASK', '/^.+(.jpe?g|.png|.svg|.ttf|.woff|.woff2|.otf|.css|.js)$/i');

/**
 * Quant verbose logging.
 */
define('QUANT_VERBOSE', 'verbose');

module_load_include('inc', 'quant', 'quant_queue_class');

/**
 * Implements hook_help().
 */
function quant_help($section) {
  switch ($section) {
    case 'quant/config':
      return '';

    case 'quant/api':
      return '';
  }
}

/**
 * Implements hook_menu().
 */
function quant_menu() {
  $items['admin/config/services/quant'] = array(
    'title' => 'Quant',
    'description' => 'Configure the Quant static site generator.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('quant_config'),
    'file' => 'quant.admin.inc',
    'access arguments' => array('configure quant'),
    'type' => MENU_NORMAL_ITEM,
  );

  $items['admin/config/services/quant/settings'] = array(
    'title' => 'Config',
    'description' => 'Configure the Quant static site generator.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('quant_config'),
    'file' => 'quant.admin.inc',
    'access arguments' => array('configure quant'),
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => 0,
  );

  $items['admin/config/services/quant/seed'] = array(
    'title' => 'Seed',
    'description' => 'Hydrate the static representation of the Drupal site.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('quant_seed_settings'),
    'file' => 'quant.admin.inc',
    'access arguments' => array('bulk quant export'),
    'type' => MENU_LOCAL_TASK,
    'weight' => 1,
  );

  $items['admin/config/services/quant/queue'] = array(
    'title' => 'Queue',
    'description' => 'Prepared items ready to be sent to Quant.',
    'page callback' => 'quant_queue_page',
    'file' => 'quant.admin.inc',
    'access arguments' => array('configure quant'),
    'type' => MENU_LOCAL_TASK,
    'weight' => 10,
  );

  $items['admin/config/services/quant/token'] = array(
    'title' => 'Token',
    'description' => 'Configure the Quant internal token system',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('quant_token_settings'),
    'file' => 'quant.admin.inc',
    'access arguments' => array('configure quant'),
    'type' => MENU_LOCAL_TASK,
    'weight' => 3
  );

  $items['_quant/validate'] = array(
    'title' => 'Validate',
    'description' => 'Validate the Quant configuration',
    'page callback' => 'quant_validate',
    'file' => 'quant.admin.inc',
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );

  // Custom Quant view controller.
  $items['node/%node/quant'] = array(
    'title callback' => 'quant_page_title',
    'title arguments' => array(1),
    'page callback' => 'quant_page_view',
    'page arguments' => array(1),
    'file' => 'quant.renderer.inc',
    'access callback' => TRUE,
  );

  return $items;
}

/**
 * Implements hook_cron_queue_info().
 */
function quant_cron_queue_info() {
  $queues['quant_seed'] = array(
    'worker callback' => 'quant_queue_worker',
  );

  if (drupal_is_cli() && module_exists('quant_cron')) {
    // Module name clashes with hook system resulting in
    // drush overriding with null pointer.
    // @see https://www.drupal.org/project/queue_ui/issues/1233682.
    $queues['quant_seed']['cron'] = array(
      'callback' => 'quant_queue_worker',
    );
  }

  return $queues;
}

/**
 * Implements hook_menu_alter().
 *
 * We intercept the standard route wildcard argument loader
 * and replace it with quant_node_menu_load. This allows
 * us to load a revision with a query parameter and have the
 * standard router context continue to operate as expected.
 */
function quant_menu_alter(&$items) {
  // Altering the node route breaks displaysuite.
  if (variable_get('disable_content_drafts', FALSE)) {
    return;
  }
  $node_route = $items['node/%node'];
  unset($items['node/%node']);
  $items['node/%quant_node_menu'] = $node_route;
}

/**
 * Implements hook_admin_paths().
 */
function quant_admin_paths() {
  $paths['admin/config/services/quant'] = TRUE;
  $paths['admin/config/services/quant/*'] = TRUE;
  $paths['node/%node/quant'] = FALSE;
  return $paths;
}

/**
 * Implements hook_permission().
 */
function quant_permission() {
  return array(
    'configure quant' => array(
      'description' => t('Configure the Quant exporter'),
      'title' => t('Configure Quant'),
      'restrict access' => TRUE,
    ),
    'bulk quant export' => array(
      'description' => t('Trigger a bulk export/seed via Quant'),
      'title' => t('Bulk Quant Export'),
      'restrict access' => TRUE,
    ),
  );
}

/**
 * Wildcard menu node loader.
 */
function quant_node_menu_load($nid) {

  $revision = _quant_get_request_header('quant-revision');
  if (!empty($revision)) {
    $node = node_load($nid, $revision);
    // Override the status. This prevents Drupal from adding the standard
    // unpublished classes to the node.
    if (!empty($node)) {
      $node->status = 1;
      return $node;
    }
  }

  return node_load($nid);
}

/**
 * Implements hook_menu_local_tasks_alter().
 */
function quant_menu_local_tasks_alter(&$data, $router_item, $root_path) {
  $token = _quant_get_request_header('quant-token');
  if (!empty($token)) {
    unset($data['tabs']);
  }
}

/**
 * Access denied response.
 */
function quant_forbidden() {
  http_response_code(403);
  die('Forbidden');
}

/**
 * Implements hook_init().
 *
 * Perform token validation at the beginning of the request. This allows us to
 * generate a token for the request and then embed resources into the page without
 * clashing with node_access restrictions.
 */
function quant_init() {
  if (empty(_quant_get_request_header('quant-token'))) {
    // Skip token checking if we don't have a token - this will
    // allow the site to operate correctly in normal browsing
    // patterns.
    return;
  }

  $path = current_path();
  $path_alias = drupal_lookup_path('alias', $path);
  $strict = variable_get('quant_token_strict', true);

  if (quant_token_validate($path_alias, $strict)) {
    return;
  }

  if (quant_token_validate($path, $strict)) {
    return;
  }

  quant_forbidden();
}

/**
 * Implements hook_node_load().
 */
function quant_node_load($nodes) {
  if (empty(_quant_get_request_header('quant-token'))) {
    return;
  }

  foreach ($nodes as $node) {
    $path = drupal_lookup_path('alias', "node/{$node->nid}");
    if (quant_token_validate($path, FALSE)) {
      $node->status = 1;
    }
  }
}

/**
 * Implements hook_node_insert().
 */
function quant_node_insert($node) {
  if (!quant_is_enabled('nodes')) {
    return;
  }

  $entity_info = array(
    'entity' => $node,
    'type' => 'node',
    'op' => 'insert',
    'original' => $node,
  );

  if (!empty($node->op)) {
    drupal_register_shutdown_function('_quant_shutdown', $entity_info);
  }
}

/**
 * Implements hook_node_update().
 */
function quant_node_update($node) {
  if (!quant_is_enabled('nodes')) {
    return;
  }

  $original = isset($entity->original) ? $entity->original : NULL;
  $entity_info = array(
    'entity' => $node,
    'type' => 'node',
    'op' => 'update',
    'original' => $original,
  );

  if (!empty($node->op)) {
    drupal_register_shutdown_function('_quant_shutdown', $entity_info);
  }
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function quant_form_node_delete_confirm_alter(&$form, $form_state, $id) {
  if (!quant_is_enabled('nodes')) {
    return;
  }

  list($url) = _quant_prepare_entity('node', $form['nid']['#value']);
  $form['alias'] = [
    '#type' => 'value',
    '#value' => $url,
  ];

  // Drupal 7 doesn't have a pre-delete operation, so we need to hook
  // into the delete confirmation form to get the alias.
  $form['#submit'][] = 'quant_node_delete_form_action';
}

/**
 * Callback for the delete form.
 */
function quant_node_delete_form_action($form, $form_state) {
  quant_api_unpublish_route($form_state['values']['alias']);
}

/**
 * Implements hook_taxonomy_term_insert().
 */
function quant_taxonomy_term_insert($term) {
  if (!quant_is_enabled('taxonomy')) {
    return;
  }

  $entity_info = array(
    'entity' => $term,
    'type' => 'taxonomy_term',
    'op' => 'insert',
    'original' => $term,
  );

  drupal_register_shutdown_function('_quant_shutdown', $entity_info);
}

/**
 * Implements hook_taxonomy_term_update().
 */
function quant_taxonomy_term_update($term) {
  if (!quant_is_enabled('taxonomy')) {
    return;
  }

  $entity_info = array(
    'entity' => $term,
    'type' => 'taxonomy_term',
    'op' => 'insert',
    'original' => $term,
  );

  drupal_register_shutdown_function('_quant_shutdown', $entity_info);
}

/**
 * Intermediary shutdown function.
 *
 * This is an intermediary shutdown function to ensure that Quant's
 * export will always be run after other processes.
 */
function _quant_shutdown($entity_info) {
  drupal_register_shutdown_function('_quant_post_entity_op', $entity_info);
}

/**
 * Post entity operation hook.
 *
 * This should be registered as a shutdown function so that it
 * can operate after the db_transaction has finished.
 */
function _quant_post_entity_op($entity_info) {
  list($id) = entity_extract_ids($entity_info['type'], $entity_info['entity']);
  list($url, $context) = _quant_prepare_entity($entity_info['type'], $id);

  if (isset($entity_info['token'])) {
    $context['token'] = $entity_info['token'];
  }

  $context['id'] = $id;
  quant_seed($url, $context);
}

/**
 * Seed a url.
 *
 * @param string $url
 *   The url to seed.
 * @param array $context
 *   The context of the seed, usually includes entity info.
 */
function quant_seed($url, array $context = array()) {
  global $base_url;
  $base = quant_get_base_url();
  $path = parse_url($url, PHP_URL_PATH);
  $path = ltrim($path, '/');

  // Ensure URL is processed to account for special character encoding.
  $url = _rebuild_url($url);

  if (path_is_admin($path)) {
    quant_log('Skip: !path is an admin path', array('!path' => $path));
    return;
  }

  quant_log('Sending content: !url', array('!url' => $url));

  $options = array(
    'headers' => array(
      'Host' => variable_get('quant_hostname', parse_url($base_url, PHP_URL_HOST)),
      'User-Agent' => 'Quant (+http://quantcdn.io)',
    ),
  );

  // Ensure Quant internal requests are signed.
  $options['headers']['quant-token'] = quant_token_create($url);

  if (isset($context['vid']) && $context['type'] == 'node') {
    $options['headers']['quant-revision'] = $context['vid'];
  }

  if (!variable_get('quant_verify_ssl', TRUE)) {
    $options['context'] = stream_context_create(array(
      'ssl' => array(
        'verify_peer' => FALSE,
        'verify_peer_name' => FALSE,
      )
    ));
  }

  $response = drupal_http_request($url, $options);

  // Ensure file entities have their underlying asset seeded.
  if (isset($context['type']) && $context['type'] == 'file') {

    // Public file handler
    if(strpos($context['entity']->uri, "public://" ) === 0) {

      // Seed the underlying file to the web-accessible public files path.
      $file_on_disk = drupal_realpath($context['entity']->uri);

      // File exists in filesystem.
      if (!empty($file_on_disk)) {

        $public_path = $file_on_disk;
        if (substr($file_on_disk, 0, strlen(DRUPAL_ROOT)) == DRUPAL_ROOT) {
          $public_path = substr($file_on_disk, strlen(DRUPAL_ROOT));
        }

        // Create a redirect from file download uri location to public file path.
        if (module_exists('quant_redirect')) {
          $download_uri = file_entity_download_uri($context['entity']);
          $download_path = url($download_uri['path'], $download_uri['options']);

          // We purposefully exclude the token from file paths.
          $download_path = parse_url($download_path, PHP_URL_PATH);
          quant_redirect_request($download_path, $public_path, 301);
        }

        $fileCtx = array(
          'location' => $context['entity']->uri,
          'request' => $public_path,
        );

        quant_seed_file("{$base}{$public_path}", $fileCtx);
      }
    }
  }

  // Add a redirect if 301|302.
  if (isset($response->redirect_code) && ($response->redirect_code == 301 || $response->redirect_code == 302)) {
    // Strip Quant params from destination.
    $dest = $response->redirect_url;

    // Ensure relative for internal redirect.
    $dest = _rewrite_relative($dest);

    if (module_exists('quant_redirect')) {
      quant_redirect_request($path, $dest, (int) $response->redirect_code);
    }

    // Ensure internal redirects have their destination seeded.
    if (_is_url_internal($dest)) {

      $dest_path = parse_url($dest, PHP_URL_PATH);

      if (isset($context['type']) && $context['type'] == 'file') {
        // File asset already handled.
        return;
      }
      else {
        quant_seed("{$base}{$dest_path}", array());
      }
    }

    // Redirect created, internal redirect followed + seeded.
    return;
  }

  if (($response->code == 404 || $response->code == 403) && strpos($url, '/_quant404') === FALSE) {
    // Ensure that the route is not accessible in Quant.
    quant_api_unpublish_route($url);
    return FALSE;
  }

  if (!property_exists($response, 'data') || $response->code > 404) {
    quant_log('Unable to seed %url %error %request', array(
      '%url' => $url,
      '%error' => $response->error,
      '%request' => json_encode($response),
    ), WATCHDOG_ERROR);
    return FALSE;
  }

  if ($response->code != 200) {
    quant_log('Non-200 response code for %url %status_code', array(
      '%url' => $url,
      '%status_code' => $response->code,
    ), WATCHDOG_WARNING);
    return FALSE;
  }

  $markup = $response->data;
  $queue = quant_get_queue();

  // Pagination support.
  $document = new \DOMDocument();
  @$document->loadHTML($markup);
  $xpath = new \DOMXPath($document);
  $xpath_urls = isset($context['xpath_urls']) ? $context['xpath_urls'] : [];

  $xpath_selectors = array();
  $links_config = variable_get(
    'quant_xpath_selectors',
    "//a[contains(@href,\"page=\") and contains(text(), \"next\")]\r\n//a[starts-with(@href, \"/\") and contains(text(), \"first\")]"
  );

  foreach (explode(PHP_EOL, $links_config) as $links_line) {
    $xpath_selectors[] = trim($links_line);
  }

  foreach ($xpath_selectors as $xpath_query) {
    foreach ($xpath->query($xpath_query) as $node) {
      $original_href = $new_href = $node->getAttribute('href');
      if ($original_href[0] === '?') {
        $new_href = strtok($path, '?') . $original_href;
      }

      $xpath_url = $base . $new_href;

      if (in_array($xpath_url, $xpath_urls)) {
        continue;
      }

      $xpath_urls[] = $xpath_url;
      $next_context = array(
        'find_pager' => TRUE,
        'type' => 'view',
        'xpath_urls' => $xpath_urls,
      );
      $item = array('quant_seed', array($xpath_url, $next_context));
      $queue->createItem($item);
    }
  }

  // Rewrite absolute URLs if relevant.
  if (variable_get('quant_rewrite_relative', FALSE)) {
    $markup = _rewrite_relative($markup);
  }

  $alias = parse_url($url, PHP_URL_PATH);
  $alias = empty($alias) ? '/' : $alias;

  // Support query parameters (pagination).
  $query = parse_url($url, PHP_URL_QUERY);
  $alias = !empty($query) ? $alias . "?{$query}" : $alias;

  $meta = [
    'published' => TRUE,
    'transitions' => [],
    'info' => [],
  ];

  if (!empty($response->headers['content-type'])) {
    $meta['content_type'] = $response->headers['content-type'];
  }

  if (isset($context['type'])) {
    drupal_alter("quant_meta_{$context['type']}", $meta, $context);
  }

  drupal_alter('quant_meta', $meta, $context);
  module_invoke_all('quant_seed', $alias, $markup, $meta, $context);
}

/**
 * Prepare a file export.
 */
function quant_seed_file($url, $context = array()) {

  quant_log('Sending file: !url', array('!url' => urldecode($url)));

  // @TODO: Files need different meta?
  $meta = array();
  drupal_alter('quant_file_meta', $meta, $context);
  module_invoke_all('quant_seed_file', $url, $context);
}

/**
 * Drush or watchdog logging.
 */
function quant_log($message, $replacements = array(), $level = WATCHDOG_INFO) {
  $vvv = variable_get('quant_verbose_logging', FALSE);

  if ($level == QUANT_VERBOSE && !$vvv) {
    return;
  }

  if ($level == QUANT_VERBOSE) {
    $level = WATCHDOG_INFO;
  }

  if (drupal_is_cli()) {
    // phpcs:ignore
    drush_log(t($message, $replacements), 'ok');
    return;
  }

  watchdog('quant', $message, $replacements, $level);
}

/**
 * Implements hook_quant_meta_TYPE_alter().
 */
function quant_quant_meta_node_alter(&$meta, $context) {
  $meta['published'] = boolval($context['entity']->status);
  $meta['content_timestamp'] = $context['entity']->changed;
  $meta['info'] = [
    'author_name' => empty($context['entity']->revision_uid) ? $context['entity']->uid : $context['entity']->revision_uid,
  ];

  // Search record (node only).
  $tags = [];
  $results = db_query('SELECT tid FROM {taxonomy_index} WHERE nid = :nid', array(':nid' => $context['entity']->nid));
  foreach ($results as $result) {
    $term = taxonomy_term_load($result->tid);
    $tags[$term->vocabulary_machine_name][] = $term->name;
  }

  $meta['search_record']['categories'] = $tags;
  $meta['search_record']['categories']['content_type'] = node_type_get_name($context['entity']);

}

/**
 * Implements hook_quant_meta_TYPE_alter().
 */
function quant_quant_meta_taxonomy_term(&$meta, $context) {
  global $user;
  $meta['info'] = [
    'author_name' => $user->uid,
  ];
  $meta['content_timestamp'] = time();
}

/**
 * Implements hook_quant_meta_alter().
 */
function quant_quant_meta_alter(&$meta, $context) {
  $meta['proxy_override'] = boolval(variable_get('quant_proxy_override', FALSE));
  if (!isset($meta['published'])) {
    // Assume the asset is to be published if not set.
    $meta['published'] = TRUE;
  }
}

/**
 * Prepare an entity for exporting.
 *
 * @return array
 *   The path with context for seeding.
 */
function _quant_prepare_entity($type, $entity_id) {
  global $base_url;
  $base = variable_get('quant_base_url', $base_url);
  $entity = entity_load($type, [$entity_id]);

  if (is_array($entity)) {
    $entity = reset($entity);
  }

  if (empty($entity)) {
    return FALSE;
  }

  switch ($type) {
    case 'file':
      $uri = entity_uri($type, $entity);
      if (!empty($uri)) {
        $path = $uri['path'];
        $alias = drupal_get_path_alias($path);
        $url = "$base/$alias";
      }
      break;

    default:
      $uri = entity_uri($type, $entity);
      if (!empty($uri)) {
        $path = $uri['path'];
        $alias = drupal_get_path_alias($path);
        $url = "$base/$alias";
      }
      break;
  }

  // Sometimes the URI can be empty, so log this.
  if (empty($uri)) {
    quant_log('No URI found for entity !type !entity_id',
      array(
        '!type' => $type,
        '!entity_id' => $entity_id,
      ),
      WATCHDOG_WARNING);
    return FALSE;
  }

  list($id, $vid) = entity_extract_ids($type, $entity);

  return array(
    $url,
    array(
      'entity' => $entity,
      'vid' => $vid,
      'id' => $id,
      'type' => $type,
    ),
  );
}

/**
 * Prepare a batch process for the node entity type.
 *
 * @param array $bundles
 *   Optionally filter by node bundles.
 */
function _quant_queue_nodes(array $bundles = array()) {
  global $base_url;
  $base = variable_get('quant_base_url', $base_url);

  $queue = quant_get_queue();

  $query = db_select('node', 'n')
    ->fields('n', array('nid'))
    ->condition('status', 1);

  if (!empty($bundles)) {
    $query->condition('n.type', array_keys($bundles), 'IN');
  }

  $nids = $query->execute()->fetchCol();
  asort($nids);

  $item = array('quant_seed', array("$base/"));
  $queue->createItem($item);

  foreach ($nids as $nid) {
    quant_log('Quant: Adding node [!nid] to the list.', array('!nid' => $nid));
    $item = array(
      'quant_seed_node_batch',
      array($nid),
    );
    if (!$queue->createItem($item)) {
      quant_log('...Skipping duplicate entity');
    }
  }
}

/**
 * Prepare a batch process for taxonomy entities.
 */
function _quant_queue_taxonomy() {
  global $base_url;
  $base = variable_get('quant_base_url', $base_url);

  $queue = quant_get_queue();

  // @todo: Support select vocabs.
  $tids = db_select('taxonomy_term_data', 't')
    ->fields('t', array('tid'))
    ->execute()
    ->fetchCol();
  asort($tids);

  foreach ($tids as $tid) {
    quant_log('Quant: Adding term [!tid] to the list.', array('!tid' => $tid));
    $item = array(
      'quant_seed_taxonomy_batch',
      array($tid),
    );
    $queue->createItem($item);
  }
}

/**
 * Prepare the images to seed via batch.
 */
function _quant_queue_theme_assets() {
  $theme_dir = drupal_get_path('theme', variable_get('theme_default', NULL));
  $files = file_scan_directory(DRUPAL_ROOT . "/$theme_dir", QUANT_THEME_FILE_MASK);
  ksort($files);

  $queue = quant_get_queue();

  // Allow modules to provide some files if they need to.
  drupal_alter('quant_seed_files', $files);

  foreach ($files as $file) {

    // Skip node_modules.
    if (preg_match('/node_modules/i', $file->uri)) {
      continue;
    }

    $file_on_disk = $file->uri;
    if (substr($file_on_disk, 0, strlen(DRUPAL_ROOT)) == DRUPAL_ROOT) {
      $file_on_disk = substr($file_on_disk, strlen(DRUPAL_ROOT));
    }

    $context = array(
      'location' => $file->uri,
      'request' => $file_on_disk,
    );

    quant_log('Quant: Adding file [!path] to the list.', array('!path' => $file_on_disk));

    $item = array(
      'quant_seed_file',
      array($file_on_disk, $context),
    );
    $queue->createItem($item);
  }
}

/**
 * Get a list of page manager paths.
 */
function _quant_queue_page_manager() {
  global $base_url;
  $base = variable_get('quant_base_url', $base_url);
  $queue = quant_get_queue();

  $config = array();
  $pages = db_query('SELECT p.path FROM {page_manager_pages} p')->fetchAll();

  foreach ($pages as $page) {
    $url = "$base/" . $page->path;

    $config['find_pager'] = TRUE;
    $config['type'] = 'page_manager';

    $item = array(
      'quant_seed',
      array(trim($url), $config),
    );
    $queue->createItem($item);
  }
}

/**
 * Get a list of views paths.
 */
function _quant_queue_views() {
  global $base_url;
  $base = variable_get('quant_base_url', $base_url);

  $queue = quant_get_queue();

  $menus = array();

  if (module_exists('views')) {
    views_menu_alter($menus);
  }

  foreach ($menus as $path => $config) {
    $url = "$base/$path";

    $config['find_pager'] = TRUE;
    $config['type'] = 'view';

    // @TODO: We have menu access callbacks so we should
    // validate anonymous has access before we add the operation.
    // Pages will be exported to Quant with 401.
    $item = array(
      'quant_seed',
      array($url, $config),
    );
    $queue->createItem($item);
  }
}

/**
 * Generate a batch of arbitrary routes.
 *
 * @param string $routes
 *   Textarea entered routes.
 */
function _quant_queue_routes($routes) {
  global $base_url;
  $base = variable_get('quant_base_url', $base_url);
  $routes = is_array($routes) ? $routes : explode(PHP_EOL, $routes);

  $queue = quant_get_queue();

  foreach ($routes as $route) {
    if (strpos((trim($route)), '/') !== 0) {
      continue;
    }

    $url = $base . $route;

    $item = array(
      'quant_seed',
      array(trim($url)),
    );
    $queue->createItem($item);
  }
}

/**
 * Expensive node preparation to begin the seed.
 */
function quant_seed_node_batch($nid) {
  list($url, $context) = _quant_prepare_entity('node', $nid);
  quant_seed($url, $context);
}

/**
 * Batch processor for exporting taxonomy terms.
 */
function quant_seed_taxonomy_batch($tid) {
  list($url, $context) = _quant_prepare_entity('taxonomy_term', $tid);

  // Find pagination within taxonomy term pages.
  $context['find_pager'] = TRUE;
  $context['type'] = 'taxonomy_term';

  quant_seed($url, $context);
}

/**
 * Generate the quant_seed queue.
 *
 * @param bool $items
 *   Return items or the queue instance.
 *
 * @return mixed
 *   A queue instance or queue items.
 */
function quant_get_queue($items = FALSE) {
  if ($items) {
    $items = array();
    $query = db_select('quant_queue', 'q')->extend('PagerDefault');
    $query->condition('name', 'quant_seed')
      ->fields('q', array('item_id', 'data', 'expire', 'created'));
    $result = $query->limit(10)->orderBy('q.item_id')->execute();
    foreach ($result as $item) {
      $items[] = (array) $item;
    }
    return $items;
  }

  $queue = DrupalQueue::get('quant_seed');
  $queue->createQueue();
  return $queue;
}

/**
 * Process the queue.
 */
function quant_queue_worker($data) {
  list($op, $args) = $data;
  if (is_callable($op)) {
    call_user_func_array($op, $args);
  }
  else {
    quant_log('Unsupported callback: [%op]', array('%op' => $op));
  }
}

/**
 * Create the batch process to export the form.
 *
 * @param array $form
 *   The form render array.
 * @param array $form_state
 *   The submitted form values.
 */
function _quant_seed_prepare(array $form = array(), array $form_state = array()) {
  $queue = quant_get_queue();

  // Reset the queue whenever we want to fully prepare a seed.
  $queue->deleteQueue();
  $queue->createQueue();

  $routes = array();

  if (variable_get('quant_seed_entity_node')) {
    $node_bundles = array_filter(variable_get('quant_seed_entity_node_bundles'));
    _quant_queue_nodes($node_bundles);
  }

  if (variable_get('quant_seed_entity_taxonomy')) {
    _quant_queue_taxonomy();
  }

  if (variable_get('quant_seed_theme_assets')) {
    _quant_queue_theme_assets();
  }

  if (variable_get('quant_seed_views')) {
    _quant_queue_views();
  }

  if (variable_get('quant_seed_page_manager')) {
    _quant_queue_page_manager();
  }

  if (variable_get('site_404', FALSE)) {
    $routes = array('/_quant404');
  }

  if (variable_get('quant_custom_routes_enabled')) {
    foreach (explode(PHP_EOL, variable_get('quant_custom_routes')) as $route) {
      if (strpos((trim($route)), '/') !== 0) {
        continue;
      }
      $routes[] = trim($route);
    }
  }

  if (variable_get('quant_robots')) {
    $routes[] = '/robots.txt';
  }

  _quant_queue_routes($routes);

  module_invoke_all('quant_seed_queue');
}

/**
 * Process the queue inline with a Drupal batch process.
 */
function _quant_queue_batch() {
  if (!variable_get('trigger_quant_seed')) {
    return;
  }

  _quant_seed_prepare();

  $batch = array(
    'title' => t('Quant seeding'),
    'operations' => array(),
    'finished' => '_quant_batch_complete',
    'init_message' => t('Initializing...'),
    'progress_message' => t('Operation @current out of @total'),
    'error_message' => t('Unable to export'),
    'file' => drupal_get_path('module', 'quant') . 'quant.module',
  );

  $batch['operations'][] = array('quant_batch_process_queue', array('quant_seed'));

  batch_set($batch);
}

/**
 * Batch handler to process the Quant seed queue.
 */
function quant_batch_process_queue($queue_name, &$context) {
  $queue = DrupalQueue::get($queue_name);
  $queue->createQueue();
  $item = $queue->claimItem();

  if (empty($context['sandbox']['progress'])) {
    $context['sandbox']['progress'] = 0;
    $context['sandbox']['total'] = $queue->numberOfItems();
  }

  if (!$item) {
    $context['finished'] = 1;
    return FALSE;
  }

  quant_queue_worker($item->data);
  $queue->deleteItem($item);
  $context['sandbox']['progress']++;

  // Callbacks can add additional items to the queue, by setting this
  // each batch run we can continuously progress through the queue
  // until completed.
  if ($queue->numberOfItems() > 0) {
    $context['message'] = t('Processed @i of @t', array(
      '@i' => $context['sandbox']['progress'],
      '@t' => $context['sandbox']['total'],
    ));
    // This will cause the progress bar to hang at 90% if additional
    // queue items are added during the run.
    $context['finished'] = $context['sandbox']['progress'] / $context['sandbox']['total'] >= 1 ? 0.9 : $context['sandbox']['progress'] / $context['sandbox']['total'];
  }
}

/**
 * Generate warning messages for the seed form.
 *
 * @param array &$form
 *   The form render array.
 */
function _quant_get_seed_warnings(array &$form) {
  $cssagg = variable_get('preprocess_css');
  $jsagg = variable_get('preprocess_js');

  if ($cssagg == 1 && $jsagg == 1) {
    // Good things get no warnings.
    return;
  }

  if ($cssagg == 0) {
    drupal_set_message(t('CSS aggregation is disabled'), 'warning');
  }

  if ($jsagg == 0) {
    drupal_set_message(t('JS aggregation is disabled'), 'warning');
  }

  drupal_set_message(t('This could lead to performance issues. To resolve, visit /admin/config/development/performance'), 'warning');
}

/**
 * Export static pages.
 *
 * This gathers front and error pages and prepares them to be
 * exported.
 */
function quant_export_drupal_pages() {
  global $base_url;
  $base = variable_get('quant_base_url', $base_url);

  $special_pages = array(
    '/' => variable_get('site_frontpage', 'node'),
    '/_quant404' => variable_get('site_404'),
    '/_quant403' => variable_get('site_403'),
  );

  foreach ($special_pages as $path => $route) {
    if (empty($route)) {
      continue;
    }
    quant_seed("{$base}{$path}", array());
  }
}

/**
 * Prepare a JWT header part.
 *
 * @param array|string $part
 *   The part to encode.
 *
 * @return string
 *   base64encoded string.
 */
function quant_jwt_encode($part = []) {
  if (is_array($part)) {
    $part = json_encode($part);
  }
  $encoded = base64_encode($part);

  if ($encoded === FALSE) {
    throw new \Exception('Unable to encode part.');
  }

  $encoded = strtr($encoded, '+/', '-_');
  return rtrim($encoded, '=');
}

/**
 * Reverse the JWT encode.
 *
 * @param string $string
 *   The encoded string.
 * @param bool $strict
 *   Base64 in strict mode.
 *
 * @return string|array
 *   The decoded URL part.
 */
function quant_jwt_decode($string, $strict = FALSE) {
    $string = strtr($string, '-_', '+/');
    $part = base64_decode($string, $strict);
    $array_part = json_decode($part, TRUE);
    return empty($array_part) ? $part : $array_part;
  }

/**
 * Add a short-lived token to the table.
 *
 * @return string
 *   The generated token.
 */
function quant_token_create($route) {
  $secret = variable_get('quant_token_secret', 'supersecret');
  $time = new DateTime(variable_get('quant_token_timeout', '+1 minute'));

  $header = ['typ' => 'JWT', 'alg' => 'HS256'];
  $payload = [
    'user' => 'quant',
    'route' => PARSE_URL($route, PHP_URL_PATH),
    'expires' => $time->format('U'),
  ];

  $header = quant_jwt_encode($header);
  $payload = quant_jwt_encode($payload);
  $signature = hash_hmac('sha256', "$header.$payload", $secret, TRUE);

  return "$header.$payload." . quant_jwt_encode($signature);
}

/**
 * Load and validate a token.
 *
 * @return bool
 *   If the token is valid.
 */
function quant_token_validate($route, $strict = TRUE) {
  $token = _quant_get_request_header('quant-token');
  $secret = variable_get('quant_token_secret', 'supersecret');
  $current_time = new DateTime;

  if (variable_get('quant_token_disable', FALSE)) {
    // If token validation is disabled we assume the user has access
    // to the request.
    return TRUE;
  }

  if (empty($token)) {
    return FALSE;
  }

  $token_parts = explode('.', $token);
  $header = quant_jwt_decode($token_parts[0]);
  $payload = quant_jwt_decode($token_parts[1]);

  $provided_signature = $token_parts[2];

  $signature = hash_hmac('sha256', "{$token_parts[0]}.{$token_parts[1]}", $secret, TRUE);
  $signature = quant_jwt_encode($signature);

  if ($signature !== $provided_signature || empty($payload['expires'])) {
    watchdog('quant_token', 'Invalid token [@token]', array('@token' => $token), WATCHDOG_INFO);
    return FALSE;
  }

  $request_time = new DateTime();
  $request_time->setTimestamp($payload['expires']);
  $date_diff = $current_time->diff($request_time);

  // The %r format will return empty string or '-' if the diff is
  // in the past, we can use this to determine if the date diff
  // is negative and restrict access accordingly.
  // @see https://www.php.net/manual/en/dateinterval.format.php
  if (!empty($date_diff->format('%r'))) {
    watchdog('quant_token', 'Expired token: Expected [@time] Received [@cur_time] (@diff)', array(
      '@time' => $request_time->format('d/m/y H:m:s'),
      '@cur_time' => $current_time->format('d/m/y H:m:s'),
      '@diff' => $date_diff->format('%r'),
    ), WATCHDOG_INFO);
    return FALSE;
  }

  $expected_route = parse_url(ltrim($route, '/'), PHP_URL_PATH);
  $received_route = parse_url(ltrim($payload['route'], '/'), PHP_URL_PATH);

  if ($strict && $expected_route != $received_route) {
    watchdog('quant_token', 'Strict token mismatch: Expected [@expected] Received [@received]', array(
      '@expected' => $expected_route,
      '@received' => $received_route,
    ), WATCHDOG_INFO);
    return FALSE;
  }

  return TRUE;
}

/**
 * Replaces absolute URLs with relative in markup.
 */
function _rewrite_relative($markup) {
  global $base_url;
  $base = variable_get('quant_hostname', $base_url);
  return preg_replace("/(https?:\/\/)?{$base}/i", '', $markup);
}

/**
 * Determines whether a URL is internal or external.
 */
function _is_url_internal($url) {
  global $base_url;
  $base = variable_get('quant_hostname', $base_url);
  if (preg_match("/(https?:\/\/)?{$base}/i", $url)) {
    return TRUE;
  }

  if (strpos($url, '/') === 0) {
    return TRUE;
  }

  return FALSE;
}

/**
 * Implements hook_form_FORM_ID_alert().
 */
function quant_form_workbench_moderation_moderate_form_alter(&$form, $form_state, $id) {
  $form['#submit'][] = 'quant_workbench_moderation_submit';
}

/**
 * Form submission handler.
 *
 * @see workbench_moderation_moderate_form_submit
 */
function quant_workbench_moderation_submit($form, $form_state) {
  $node = $form['node']['#value'];

  $entity_info = array(
    'entity' => $node,
    'type' => 'node',
    'op' => 'update',
    'original' => $node->original,
  );

  if ($form_state['values']['state'] == workbench_moderation_state_published()) {
    drupal_register_shutdown_function('_quant_shutdown', $entity_info);
  }
  else {
    list($url) = _quant_prepare_entity('node', $form['node']['#value']->nid);
    quant_api_unpublish_route($form_state['values']['alias']);
  }
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function quant_form_system_site_information_settings_alter(&$form, $form_state) {
  $form['#submit'][] = 'quant_seed_errors';
}

/**
 * Seed error pages when they're updated.
 */
function quant_seed_errors() {
  global $base_url;
  $base = variable_get('quant_base_url', $base_url);
  if (variable_get('site_404', FALSE)) {
    quant_seed("$base/_quant404");
  }
}

/**
 * Determine if quant is enabled.
 *
 * @param string $type
 *   A type of entity that is to be exported.
 *
 * @return bool
 *   If quant is enabled.
 */
function quant_is_enabled($type = NULL) {
  $quant_enabled = variable_get('quant_enabled', TRUE);

  if (is_null($type)) {
    return $quant_enabled;
  }

  return (bool) ($quant_enabled && variable_get('quant_enabled_' . $type, FALSE));
}

/**
 * Helper function to retrieve request header value.
 *
 * @param string $header
 *   The name of a request header to retrieve.
 *
 * @return mixed
 *   FALSE if not present, else the value of the header.
 */
function _quant_get_request_header($header) {
  foreach ($_SERVER as $name => $value) {
    /* RFC2616 (HTTP/1.1) defines header fields as case-insensitive entities. */
    if (strtolower(str_replace('_', '-', substr($name, 5))) == strtolower($header)) {
      return $value;
    }
  }
  return FALSE;
}

/**
 * Get the quant configured base URL.
 *
 * @return string
 *   The base URL.
 */
function quant_get_base_url() {
  global $base_url;
  $base = variable_get('quant_base_url', $base_url);
  return $base;
}

/**
 * Helper function to rebuild a URL with encoded path.
 *
 * @param string $url
 *   The URL to rebuild.
 *
 * @return string
 *   The rebuild URL for drupal_http_request.
 */
function _rebuild_url($url) {

  // Parse the URL to capture query parameters (if any).
  $parsed_url = parse_url($url);

  // Return the raw string if we cannot parse the URL.
  if (empty($parsed_url['path']) || $parsed_url['path'] == '/') {
    return $url;
  }

  // First decode the path so we can ensure consistent encoding.
  $parts = explode('/', rtrim($parsed_url['path'], '/'));
  $cleansed = [];
  foreach ($parts as $part) {
    $path = urldecode($part);
    $cleansed[] = rawurlencode($part);
  }

  $rebuilt_url = (isset($parsed_url['scheme']) ? "{$parsed_url['scheme']}:" : '') .
    ((isset($parsed_url['user']) || isset($parsed_url['host'])) ? '//' : '') .
    (isset($parsed_url['user']) ? "{$parsed_url['user']}" : '') .
    (isset($parsed_url['pass']) ? ":{$parsed_url['pass']}" : '') .
    (isset($parsed_url['user']) ? '@' : '') .
    (isset($parsed_url['host']) ? "{$parsed_url['host']}" : '') .
    (isset($parsed_url['port']) ? ":{$parsed_url['port']}" : '') .
    implode('/', $cleansed).
    (isset($parsed_url['query']) ? "?{$parsed_url['query']}" : '');

  return $rebuilt_url;
}

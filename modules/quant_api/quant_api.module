<?php

/**
 * @file
 * Hook implementations for quant_api.
 */

/**
 * The default URL endpoint for Quant.
 *
 * @var string
 */
define('QUANT_API_ENDPOINT_DEFAULT', 'https://api.quantcdn.io');

/**
 * Implements hook_help().
 */
function quant_api_help($section) {
  switch ($section) {
    case 'admin/help#quant_api':
      return quant_help('admin/help#quant');
  }
}

/**
 * Implements hook_menu().
 */
function quant_api_menu() {
  $items['admin/config/services/quant/api'] = array(
    'title' => 'API',
    'description' => 'Configure the API connection',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('quant_api_settings'),
    'file' => 'quant_api.admin.inc',
    'access arguments' => array('configure quant'),
    'type' => MENU_LOCAL_TASK,
    'weight' => 2,
  );

  return $items;
}

/**
 * Get request headers.
 *
 * @return array
 *   The standard Quant API headers.
 */
function quant_api_get_request_headers() {
  $token = variable_get('quant_api_token');
  // @todo Switch from 'quant_api_customer' to 'quant_api_organization'.
  $customer = variable_get('quant_api_customer');
  $project = variable_get('quant_api_project');

  if (empty($token)) {
    quant_log('API Token is not configured.');
    return [];
  }

  if (empty($customer)) {
    quant_log('API Organization is not configured');
    return [];
  }

  if (empty($project)) {
    quant_log('API Project is not configured');
    return [];
  }

  // @todo Switch from 'quant-customer' to 'quant-organization'.
  return array(
    'quant-customer' => $customer,
    'quant-token' => $token,
    'quant-project' => $project,
  );
}

/**
 * Implements hook_quant_seed().
 */
function quant_api_quant_seed($location, $data, $meta = [], $context = []) {
  global $base_url;

  $api = variable_get('quant_api_endpoint', QUANT_API_ENDPOINT_DEFAULT) . '/v1';

  if (empty($api)) {
    quant_log('API endpoint is not configured.');
    return;
  }

  // Ensure we have a leading forward-slash.
  $location = '/' . ltrim($location, '/');

  $data = array(
    'content' => $data,
    'url' => $location,
    'published' => $meta['published'],
    'transitions' => $meta['transitions'],
    'info' => $meta['info'],
    'proxy_override' => $meta['proxy_override'],
  );

  if (!empty($meta['search_record'])) {
    $data['search_record'] = $meta['search_record'];
  }

  $request = array(
    'headers' => quant_api_get_request_headers() + array(
      'content-type' => 'application/json',
      'User-Agent' => 'Quant (+http://quant.io)',
    ),
    'method' => 'POST',
    'data' => $data,
  );

  if (isset($meta['content_type'])) {
    $request['data']['headers']['content_type'] = $meta['content_type'];
  }

  if (!variable_get('quant_api_ssl_verify', TRUE)) {
    $request['context'] = stream_context_create(array(
      'ssl' => array(
        'verify_peer' => FALSE,
        'verify_peer_name' => FALSE,
      )
    ));
  }

  drupal_alter('quant_api_data', $request['data']);
  $request['data'] = json_encode($request['data']);
  quant_log('Request data: %request_data', array('%request_data' => $request['data']), QUANT_VERBOSE);

  $response = drupal_http_request($api, $request);

  if (!empty($response->error)) {
    if (empty($response->data)) {
      // This is a connection error between the Drupal server and Quant.
      quant_log('Connection error', [], WATCHDOG_ERROR);
      return;
    }
    $body = json_decode($response->data);
    quant_log('Error sending request: %error %response', array(
      '%error' => $body->errorMsg,
      '%response' => json_encode($response),
    ), WATCHDOG_ERROR);
    return;
  }

  $data = json_decode($response->data, TRUE);
  $media = array_merge($data['attachments']['js'], $data['attachments']['css'], $data['attachments']['media']['images'], $data['attachments']['media']['documents'], $data['attachments']['media']['video'], $data['attachments']['media']['audio']);

  if (!is_array($media)) {
    return;
  }

  foreach ($media as $item) {
    // @todo: Configurable to disallow remote files.
    $file = urldecode($item['path']);
    $on_disk = parse_url($file, PHP_URL_PATH);
    $domain = parse_url($file, PHP_URL_HOST);

    if (!empty($domain) && stripos($base_url, $domain) == -1) {
      // @todo: Determine local vs. remote.
      continue;
    }

    $loc = DRUPAL_ROOT . $on_disk;

    // Override if this looks like a private file.
    if (strpos($file, '/system/files/') !== FALSE) {
      $private_path = drupal_realpath('private://');
      $loc = str_replace('/system/files', $private_path, $file);
    }

    // Support alternate file handling if enabled
    if (variable_get('quant_alternate_file_handler', FALSE)) {
      $loc = _retrieve_file($file);
    }

    if (!file_exists($loc)) {
      quant_log('File not found: %file', array(
        '%file' => $file,
      ), QUANT_VERBOSE);
      continue;
    }

    if (isset($item['existing_md5']) && md5_file($loc) == $item['existing_md5']) {
      // This file hasn't changed since the last export.
      continue;
    }

    // @TODO - this processes inline in the batch request
    // which might cause performance problems with pages with
    // many assets.
    if (!empty($item['full_path'])) {
      $file = $item['full_path'];
    }
    quant_seed_file($file, [
      'location' => $loc,
      'request' => $on_disk,
    ]);

    // Remove temporary files where alternate file handler is enabled
    // and the file path starts with the temporary directory.
    if (variable_get('quant_alternate_file_handler', FALSE)) {
      if (strpos($loc, sys_get_temp_dir()) === 0) {
        unlink($loc);
      }
    }
  }

}

/**
 * Implements hook_quant_seed_file().
 */
function quant_api_quant_seed_file($url, $context) {
  global $base_url;

  // Rebuild the file URL used for the local HEAD request.
  $url = _rebuild_file_url($url);

  $api = variable_get('quant_api_endpoint', QUANT_API_ENDPOINT_DEFAULT) . '/v1';

  if (empty($api)) {
    quant_log('API endpoint is not configured.', [], 'info');
    return;
  }

  if (empty($context['location'])) {
    quant_log('Unable to upload %u, location not specified', ['%u' => $url]);
    return;
  }

  if (!file_exists($context['location'])) {
    quant_log('Unable to upload %u, file does not exist', ['%u' => $context['location']]);
    return;
  }

  // Issue a HEAD request to the file path.
  $options = array(
    'headers' => array(
      'Host' => variable_get('quant_hostname', parse_url($base_url, PHP_URL_HOST)),
      'User-Agent' => 'Quant (+http://quantcdn.io)',
    ),
    'method' => 'HEAD',
  );

  // Ensure url is absolute for internal HEAD request.
  if(strpos($url, "http") !== 0) {
    $base = variable_get('quant_base_url', $base_url);
    $url = "{$base}{$url}";
  }

  if (!variable_get('quant_verify_ssl', TRUE)) {
    $options['context'] = stream_context_create(array(
      'ssl' => array(
        'verify_peer' => FALSE,
        'verify_peer_name' => FALSE,
      )
    ));
  }

  $file_head = drupal_http_request($url, $options);

  // Disallow files that do not return 200 OK.
  if ($file_head->code != 200) {
    quant_log('Unable to seed file: %url. Unexpected response code: %code', array(
      '%url' => $url,
      '%code' => $file_head->code,
    ), WATCHDOG_ERROR);
    return;
  }

  // Support file specific additional headers.
  $custom_headers = array_intersect_key($file_head->headers, array_flip(array(
    'content-disposition',
    'content-transfer-encoding',
    'content-type'
  )));

  $headers = quant_api_get_request_headers() + array(
    'Quant-File-Url' => $context['request'],
    'User-Agent' => 'Quant (+http://quant.io)',
  );

  $curl_headers = array();
  foreach ($headers as $header => $value) {
    $curl_headers[] = "{$header}: {$value}";
  }

  // Add extra file headers if relevant.
  if (!empty($custom_headers)) {
    $curl_headers[] = "Quant-File-Headers: " . json_encode($custom_headers);
  }

  // Drupal HTTP request doesn't support streaming files - so we need
  // to use curl directly to support large files.
  $ch = curl_init();
  curl_setopt($ch, CURLOPT_URL, $api);
  curl_setopt($ch, CURLOPT_POST, TRUE);
  curl_setopt($ch, CURLOPT_HTTPHEADER, $curl_headers);
  curl_setopt($ch, CURLOPT_RETURNTRANSFER, TRUE);

  $data['data'] = curl_file_create(
    $context['location'],
    mime_content_type($context['location']),
    basename($context['location'])
  );

  curl_setopt($ch, CURLOPT_POSTFIELDS, $data);

  if (!variable_get('quant_api_verify_ssl', TRUE)) {
    curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, 0);
    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, 0);
  }

  $result = curl_exec($ch);
  $info = curl_getinfo($ch);
  curl_close($ch);

  if ($info['http_code'] == 413) {
    quant_log('Upload too large.');
    return FALSE;
  }

  $response = json_decode($result);

  if (!empty($response->error) && strpos("MD5 already matches", $response->errorMsg) !== FALSE) {
    quant_log('Error sending request: %error', array(
      '%error' => $response->errorMsg,
    ), WATCHDOG_ERROR);
    return FALSE;
  }

  return $response;
}

/**
 * Unpublish a Quant route.
 *
 * @param string $url
 *   The URL to unpublish.
 *
 * @return bool
 *   If the request was successful.
 */
function quant_api_unpublish_route($url) {
  $api = variable_get('quant_api_endpoint', QUANT_API_ENDPOINT_DEFAULT) . '/v1';

  $options = array(
    'headers' => quant_api_get_request_headers() + array(
      'Quant-Url' => parse_url($url, PHP_URL_PATH),
      'User-Agent' => 'Quant (+http://quant.io)',
    ),
    'method' => 'PATCH',
  );

  if (!variable_get('quant_api_ssl_verify', TRUE)) {
    $options['context'] = stream_context_create(array(
      'ssl' => array(
        'verify_peer' => FALSE,
        'verify_peer_name' => FALSE,
      )
    ));
  }

  $response = drupal_http_request("$api/unpublish", $options);
  if (!empty($response->error)) {
    if (empty($response->data)) {
      // This is a connection error between the Drupal server and Quant.
      quant_log('Connection error');
      return FALSE;
    }
    $body = json_decode($response->data);
    quant_log('Error sending request: %error', array(
      '%error' => $body->errorMsg,
    ), WATCHDOG_ERROR);
    return FALSE;
  }

  return TRUE;
}

/**
 * Rebuild a raw file URL for a local HEAD request.
 *
 * @param string $url
 *   The URL to rebuild.
 *
 * @return string
 *   The rebuild URL for drupal_http_request.
 */
function _rebuild_file_url($url) {

  // Parse the URL to capture query parameters (if any).
  $parsed_url = parse_url($url);

  // Return the raw string if we cannot parse the URL.
  if (empty($parsed_url['path'])) {
    return $url;
  }

  $parts = explode('/', rtrim($parsed_url['path'], '/'));
  $cleansed = [];
  foreach ($parts as $part) {
    $path = urldecode($part);
    $cleansed[] = rawurlencode($part);
  }

  $rebuilt_url = '/' . implode('/', $cleansed);

  if (!empty($parsed_url['query'])) {
    $rebuilt_url .= "?" . $parsed_url['query'];
  }

  return $rebuilt_url;

}

/**
 * Retrieve a file via HTTP if alternate file handling is enabled.
 *
 * This allows for an option to retrieve files using custom
 * stream wrappers (or remote) to ensure they can be included
 * in the seed operation.
 *
 * @param string $url
 *   The relative URL of a file to retrieve.
 *
 * @return string
 *   The absolute local path on disk to the temporary file.
 */
function _retrieve_file($url) {

  $path = $url;

  // Issue a GET request to the file path.
  $options = array(
    'headers' => array(
      'Host' => variable_get('quant_hostname', parse_url($base_url, PHP_URL_HOST)),
      'User-Agent' => 'Quant (+http://quantcdn.io)',
    ),
    'method' => 'GET',
  );

  // Ensure url is absolute for internal GET request.
  if(strpos($url, "http") !== 0) {
    $base = variable_get('quant_base_url', $base_url);
    $url = "{$base}{$url}";
  }

  if (!variable_get('quant_verify_ssl', TRUE)) {
    $options['context'] = stream_context_create(array(
      'ssl' => array(
        'verify_peer' => FALSE,
        'verify_peer_name' => FALSE,
      )
    ));
  }

  // Retrieve the file, store in a temporary location, and use for file upload.
  $file_get = drupal_http_request($url, $options);
  $tmp_filename = tempnam(sys_get_temp_dir(), basename($path));
  $tmp_file = fopen($tmp_filename, "w+");
  fwrite($tmp_file, $file_get->data);
  fclose($tmp_file);

  return $tmp_filename;

}
